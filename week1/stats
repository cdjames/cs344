#!/bin/bash

PROGNAME=$(basename $0)
datafilepath="datafile$$"
averages=()
medians=()
allfields=()

exit_prog() {
	#-----------
	# An error outputting function
	# Uses ideas and code from http://www.linuxcommand.org/wss0150.php
	#
	# Accepts one argument
	#-----------

	# >$2 outputs to stderr
	>&2 echo $1
	exit 1
}

usage() {
	exit_prog "Usage: stats {-rows|-cols} [file]"
}


bad_file() {
	exit_prog "${PROGNAME}: cannot read '$1'"
}

check_opts() {
	if [[ $1 == -r* ]] || [[ $1 == -c* ]]; then
		return
	fi
	usage
}

choose_path() {
	case $1 in
		"-r"*)
			# run rows version of calculation
			echo "-r!"
			;;
		"-c"*)
			# run cols version
			echo "-c!"
			;;
		*) # bad input
			usage
			;;

	esac
}

clean_up() {
	if [ -e "datafile$$" ]; then
		rm -f "datafile$$"
	fi
	exit
}

avg() {
	local total=$1
	local fields=$2
	echo "$(expr $total / $fields)"
}

# get_line() {

# }

do_calculations() {
	count=0
	outer_reps=$1
	outer_inc=$2
	inner_reps=$3
	inner_inc=$4
	divisor=$5
	mednum=$(expr \( $divisor + $6 \) / 2)
	echo "mednum=$mednum"
	for (( i = 0; i < outer_reps; i+=outer_inc )); do
		total=0
		thisline=""
		# reassemble line
		for (( x = 0; x < inner_reps; x+=inner_inc )); do
			idx=$(expr $i + $x)
			# thisline[$x]=${allfields[$idx]}
			thisline="$thisline\n${allfields[$idx]}"
			total=$(expr ${allfields[$idx]} + $total)
		done
		
		# figure average for thisline and store in averages
		averages[$count]=$(avg $total $divisor)
		echo "avgs[$count] = ${averages[$count]} "
		((count++))
		# process median
		echo -e "$(echo -e $thisline | awk '$1=$1' | sort -gb | tr "\n" " ")\n"
		median=$(echo -e $thisline | awk '$1=$1' | sort -g | tr -s "\n" "\t" | cut -f $mednum)
		echo "median=$median"
		# if [[((idx-i)) == (())]]
		echo "total=$total"
	done
}

# make sure you clean up if the program is interrupted
trap clean_up SIGINT SIGTERM SIGHUP

# figure out whether you have a file or stdin
case $# in
1) # there is only one arg
	check_opts $1
	cat > "$datafilepath"
	;;
2) # 2 args
	check_opts $1
	if [ -e $2 ]; then # file exists
		#statements
		datafilepath=$2
	else
		bad_file $2
	fi
	;;
*) # 0 or >2 args
	usage
	;;
esac

lc=$(cat $datafilepath | wc -l) # line count
fct=$(head -n 1 $datafilepath | wc -w) # field count

# put all fields from file into an array
ct=0
while IFS=$'\t' read -ra fields
do
	for i in "${fields[@]}"; do
		allfields[ct]=$i
		((ct++))
	done
done < $datafilepath

tot_fields=$(expr $lc \* $fct)
case $1 in
	"-r"*) # calc rows
		# run rows version of calculation
		echo "calc rows"
		do_calculations $tot_fields $fct $fct 1 $fct 1
		;;
	"-c"*) # calc cols
		echo "calc cols"
		do_calculations $fct 1 $tot_fields $fct $lc 2
		;;
	*) # bad input
		usage
		;;
esac

clean_up