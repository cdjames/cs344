#!/bin/bash

# some global variables
PROGNAME=$(basename $0)
datafilepath="datafile$$"
averages=()
medians=()
allfields=()

exit_prog() {
	#------------------------------------------------------------------
	# An error outputting function
	# Uses ideas and code from http://www.linuxcommand.org/wss0150.php
	#
	# $1 is the message
	#------------------------------------------------------------------

	>&2 echo $1  # >$2 outputs to stderr
	exit 1
}

usage() {
	exit_prog "Usage: stats {-rows|-cols} [file]"
}


bad_file() {
	exit_prog "${PROGNAME}: cannot read '$1'"
}

check_opts() {
	if [[ $1 == -r* ]] || [[ $1 == -c* ]]; then
		return
	fi
	usage
}

clean_up() {
	if [ -e "datafile$$" ]; then
		rm -f "datafile$$"
	fi
	exit
}

avg() {
	local total=$1
	local fields=$2
	# with help from -- http://stackoverflow.com/questions/2395284/round-a-divided-number-in-bash
	# (total + (denom/2)) / denom to round on halves or higher
	echo $(( ( $total + ($fields / 2) ) / $fields ))
}

do_calculations() {
	count=0
	outer_reps=$1
	outer_inc=$2
	inner_reps=$3
	inner_inc=$4
	divisor=$5
	roundup=2
	# roundup should be 1 for odd field counts and 2 for even ones
	if [[ "$(( $divisor % 2 ))" > 0 ]]; then
		roundup=1
	fi
	mednum=$(( ( $divisor + $roundup ) / 2 ))
	for (( i = 0; i < outer_reps; i+=outer_inc )); do
		total=0
		thisline=""
		# reassemble line
		for (( x = 0; x < inner_reps; x+=inner_inc )); do
			idx=$(( $i + $x ))
			# thisline[$x]=${allfields[$idx]}
			thisline="$thisline\n${allfields[$idx]}" # create a row of numbers as a string
			total=$(( ${allfields[$idx]} + $total ))
		done
		
		# figure average for thisline and store in averages
		averages[$count]=$(avg $total $divisor)
		
		# process median
		# awk strips whitespace
		medians[$count]=$(echo -e $thisline | awk '$1=$1' | sort -g | tr -s "\n" "\t" | cut -f $mednum)
		
		((count++))
	done
}

printrows() {
	echo "Averages Medians"
	for (( i = 0; i < ${#averages[@]}; i++ )); do
		echo -e "${averages[$i]}\t ${medians[$i]}"
	done
}

printcols() {
	echo "Averages:"
	for (( i = 0; i < ${#averages[@]}; i++ )); do
		printf "%d\t" ${averages[$i]}
	done
	echo
	echo "Medians:"
	for (( i = 0; i < ${#medians[@]}; i++ )); do
		printf "%d\t" ${medians[$i]}
	done
	echo
}

# make sure you clean up if the program is interrupted
trap clean_up SIGINT SIGTERM SIGHUP

# figure out whether you have a file or stdin
case $# in
1) # there is only one arg
	check_opts $1
	if readlink /proc/$$/fd/0 | grep -q "^pipe:"; then
		cat > "$datafilepath"
	else
		usage
	fi
	;;
2) # 2 args
	check_opts $1
	if [ -e $2 ]; then # file exists
		datafilepath=$2
	else
		bad_file $2
	fi
	;;
*) # 0 or >2 args
	usage
	;;
esac

lc=$(cat $datafilepath | wc -l) # line count
fct=$(head -n 1 $datafilepath | wc -w) # field count

# put all fields from file into an array
ct=0
while IFS=$'\t' read -ra fields
do
	for i in "${fields[@]}"; do
		allfields[ct]=$i
		((ct++))
	done
done < $datafilepath

## do calculations for either rows or columns
tot_fields=$(expr $lc \* $fct)
case $1 in
	"-r"*) # calc rows
		do_calculations $tot_fields $fct $fct 1 $fct
		printrows
		;;
	"-c"*) # calc cols
		do_calculations $fct 1 $tot_fields $fct $lc
		printcols
		;;
	*) # bad input
		usage
		;;
esac

clean_up