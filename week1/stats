#!/bin/bash

PROGNAME=$(basename $0)
datafilepath="datafile$$"
averages=()
medians=()
lines=()

exit_prog() {
	#-----------
	# An error outputting function
	# Uses ideas and code from http://www.linuxcommand.org/wss0150.php
	#
	# Accepts one argument
	#-----------

	# >$2 outputs to stderr
	>&2 echo $1
	exit 1
}

usage() {
	exit_prog "Usage: stats {-rows|-cols} [file]"
}


bad_file() {
	exit_prog "${PROGNAME}: cannot read '$1'"
}

check_opts() {
	if [[ $1 == -r* ]] || [[ $1 == -c* ]]; then
		return
	fi
	usage
}

choose_path() {
	case $1 in
		"-r"*)
			# run rows version of calculation
			echo "-r!"
			;;
		"-c"*)
			# run cols version
			echo "-c!"
			;;
		*) # bad input
			usage
			;;

	esac
}



clean_up() {
	if [ -e "datafile$$" ]; then
		rm -f "datafile$$"
	fi
	exit
}

# make sure you clean up if the program is interrupted
trap clean_up SIGINT SIGTERM SIGHUP

# figure out whether you have a file or stdin
case $# in
1) # there is only one arg
	check_opts $1
	cat > "$datafilepath"
	;;
2) # 2 args
	check_opts $1
	if [ -e $2 ]; then # file exists
		#statements
		datafilepath=$2
	else
		bad_file $2
	fi
	;;
*) # 0 or >2 args
	usage
	;;
esac

lc=$(wc -l $datafilepath | cut -d \t -f 1)
echo "$lc"

ct=0
while IFS=$'\t' read -ra fields
do
	echo "${fields[$ct]}"
	lines[$ct]=fields
	((ct++))
done < $datafilepath

choose_path $1
clean_up