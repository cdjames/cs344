#!/bin/bash

PROGNAME=$(basename $0)
datafilepath="datafile$$"
averages=()
medians=()
allfields=()

exit_prog() {
	#-----------
	# An error outputting function
	# Uses ideas and code from http://www.linuxcommand.org/wss0150.php
	#
	# Accepts one argument
	#-----------

	# >$2 outputs to stderr
	>&2 echo $1
	exit 1
}

usage() {
	exit_prog "Usage: stats {-rows|-cols} [file]"
}


bad_file() {
	exit_prog "${PROGNAME}: cannot read '$1'"
}

check_opts() {
	if [[ $1 == -r* ]] || [[ $1 == -c* ]]; then
		return
	fi
	usage
}

choose_path() {
	case $1 in
		"-r"*)
			# run rows version of calculation
			echo "-r!"
			;;
		"-c"*)
			# run cols version
			echo "-c!"
			;;
		*) # bad input
			usage
			;;

	esac
}

clean_up() {
	if [ -e "datafile$$" ]; then
		rm -f "datafile$$"
	fi
	exit
}

avg() {
	local total=$1
	local fields=$2
	local average=$(( $total / $fields ))
	# see if number needs to be rounded
	# if [ $(( $total % $fields )) ]; then
	# 	((average++))
	# fi
	echo "$average"
}

# get_line() {

# }

do_calculations() {
	count=0
	outer_reps=$1
	outer_inc=$2
	inner_reps=$3
	inner_inc=$4
	divisor=$5
	roundup=1
	if [[ $(( $divisor % 2 )) ]]; then
		roundup=2
	fi
	mednum=$(expr \( $divisor + $roundup \) / 2)
	for (( i = 0; i < outer_reps; i+=outer_inc )); do
		total=0
		thisline=""
		# reassemble line
		for (( x = 0; x < inner_reps; x+=inner_inc )); do
			idx=$(expr $i + $x)
			# thisline[$x]=${allfields[$idx]}
			thisline="$thisline\n${allfields[$idx]}"
			total=$(expr ${allfields[$idx]} + $total)
		done
		
		# figure average for thisline and store in averages
		averages[$count]=$(avg $total $divisor)
		# echo "avgs[$count] = ${averages[$count]} "
		
		# process median
		# awk strips whitespace
		# echo -e $thisline | awk '$1=$1' | sort -g | tr -s "\n" " "
		medians[$count]=$(echo -e $thisline | awk '$1=$1' | sort -g | tr -s "\n" "\t" | cut -f $mednum)
		# echo "median=${medians[$count]}"
		# echo "count=$count"
		((count++))
		# echo "total=$total"
	done
}

printrows() {
	echo "Averages Medians"
	for (( i = 0; i < ${#averages[@]}; i++ )); do
		echo -e "${averages[$i]}\t ${medians[$i]}"
	done
}

printcols() {
	echo "Averages:"
	for (( i = 0; i < ${#averages[@]}; i++ )); do
		printf "%d\t" ${averages[$i]}
	done
	echo
	echo "Medians:"
	for (( i = 0; i < ${#medians[@]}; i++ )); do
		printf "%d\t" ${medians[$i]}
	done
	echo
}

# make sure you clean up if the program is interrupted
trap clean_up SIGINT SIGTERM SIGHUP

# figure out whether you have a file or stdin
case $# in
1) # there is only one arg
	check_opts $1
	cat > "$datafilepath"
	;;
2) # 2 args
	check_opts $1
	if [ -e $2 ]; then # file exists
		#statements
		datafilepath=$2
	else
		bad_file $2
	fi
	;;
*) # 0 or >2 args
	usage
	;;
esac

lc=$(cat $datafilepath | wc -l) # line count
fct=$(head -n 1 $datafilepath | wc -w) # field count

# put all fields from file into an array
ct=0
while IFS=$'\t' read -ra fields
do
	for i in "${fields[@]}"; do
		allfields[ct]=$i
		((ct++))
	done
done < $datafilepath

## do calculations for either rows or columns
tot_fields=$(expr $lc \* $fct)
case $1 in
	"-r"*) # calc rows
		do_calculations $tot_fields $fct $fct 1 $fct
		printrows
		;;
	"-c"*) # calc cols
		do_calculations $fct 1 $tot_fields $fct $lc
		printcols
		;;
	*) # bad input
		usage
		;;
esac

clean_up